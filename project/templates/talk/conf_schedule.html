{% extends "base.html" %}
{% block content %}
<h1 class="title">SciPy.in 2011 Conference Schedule</h1>

<h2 id="sec-1">Day 1 </h2>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="right" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="right">Time</th><th scope="col" class="left">Speaker</th><th scope="col" class="left">Title</th></tr>
</thead>
<tbody>
<tr><td class="right">09:00-09:15</td><td class="left"></td><td class="left">Inauguration</td></tr>
<tr><td class="right">09:15-10:15</td><td class="left">[Invited Speaker] Eric Jones</td><td class="left"><b>Keynote: What Matters in Scientific Software Projects? 10 Years of Success and Failure Distilled</b></td></tr>
<tr><td class="right">10:15-10:45</td><td class="left"></td><td class="left">Tea Break</td></tr>
<tr><td class="right">10:45-11:05</td><td class="left">Ankur Gupta</td><td class="left"><a href="#sec2.2">Multiprocessing module and Gearman</a></td></tr>
<tr><td class="right">11:05-11:35</td><td class="left">Kunal Puri</td><td class="left"><a href="#sec2.9">Smoothed Particle Hydrodynamics with Python</a></td></tr>
<tr><td class="right">11:35-12:20</td><td class="left">[Invited Speaker] Mateusz Paprocki</td><td class="left"><b><a href = "#sec2.26">Understanding importance of automated software testing</b></a></td></tr>
<tr><td class="right">12:20-13:20</td><td class="left"></td><td class="left"><b>Lunch</b></td></tr>
<tr><td class="right">13:20-14:05</td><td class="left">[Invited Speaker] Ajith Kumar</td><td class="left"><b>Invited Talk</b></td></tr>
<tr><td class="right">14:05-14:25</td><td class="left">Bala Subrahmanyam Varanasi</td><td class="left"><a href="#sec2.6">Sentiment Analysis</a></td></tr>
<tr><td class="right">14:25-14:55</td><td class="left">Jayneil Dalal</td><td class="left"><a href="#sec2.8">Building Embedded Systems for Image Processing using Python</a></td></tr>
<tr><td class="right">14:55-15:05</td><td class="left">IITB Students[Changed to Day 2 lightning talk slot]</td><td class="left"><a href="#sec2.24">Project Presentation</a></td></tr>
<tr><td class="right">15:05-15:35</td><td class="left"></td><td class="left"><b>Tea Break</b></td></tr>
<tr><td class="right">15:35-16:20</td><td class="left">[Invited Speaker] Prabhu Ramachandran</td><td class="left"><b>Invited Talk</b></td></tr>

<tr><td class="right">16:20-16:40</td><td class="left">William Natharaj P.S</td><td class="left"><a href="#sec2.3">Automated Measurement of Magnetic properties of Ferro-Magnetic materials using Python</a></td></tr>
<tr><td class="right">16:40-17:00</td><td class="left">Nivedita Datta</td><td class="left"><a href="#sec2.10">Encryptedly yours : Python & Cryptography</a></td></tr>
<tr><td class="right">17:10-17:30</td><td class="left"></td><td class="left"><b>Lightning Talks</b></td></tr>
</tbody>
</table>


<h2 id="sec-2">Day 2 </h2>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="right" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="right">Time</th><th scope="col" class="left">Speaker</th><th scope="col" class="left">Title</th></tr>
</thead>
<tbody>
<tr><td class="right">09:00-09:45</td><td class="left">[Invited Speaker] Gaël Varoquaux</td><td class="left"><a href="#sec2.23"><b>Machine learning as a tool for Neuroscience</b></td></tr>
<tr><td class="right">09:45-10:15</td><td class="left">[Invited Speaker] Kannan Moudgalya</td><td class="left"><b>National Mission on Education Through ICT</b></td></tr>
<tr><td class="right">10:15-10:45</td><td class="left"></td><td class="left"><b>Tea</b></td></tr>
<tr><td class="right">10:45-11:05</td><td class="left">Hrishikesh Deshpande</td><td class="left"><a href="#sec2.14">Higher Order Statistics in Python</a></td></tr>
<tr><td class="right">11:05-11:25</td><td class="left">Jaidev Deshpande</td><td class="left"><a href="#sec2.18">A Python Toolbox for the Hilbert-Huang Transform</a></td></tr>
<tr><td class="right">11:25-12:10</td><td class="left">[Invited Speaker] Emmanuelle Gouillart</td><td class="left"><a href="#sec2.27"><b>3-D image processing and visualization with the scientific-Python stack</b></a></td></tr>
<tr><td class="right">12:10-13:10</td><td class="left"></td><td class="left"><b>Lunch</b></td></tr>
<tr><td class="right">13:10-13:50</td><td class="left">[Invited Speaker] Ole Nielsen/Panel Discussion with Invited Speakers</td><td class="left"><a href="#sec2.25"><b>7 Steps to Python Software That Works<a/> / Community Building in Open Source Projects</b></td></tr>
<tr><td class="right">13:50-14:20</td><td class="left">Kunal Puri</td><td class="left"><a href="#sec2.21">GPU Accelerated Computational Fluid Dynamics with Python</a></td></tr>
<tr><td class="right">14:20-14:50</td><td class="left">Chetan Giridhar</td><td class="left"><a href="#sec2.19">Diving in to Byte-code optimization in Python</a></td></tr>
<tr><td class="right">14:50-15:20</td><td class="left">Vishal Kanaujia</td><td class="left"><a href="#sec2.7">Exploiting the power of multicore for scientific computing in Python</a></td></tr>
<tr><td class="right">15:20-15:50</td><td class="left"></td><td class="left"><b>Tea</b></td></tr>
<tr><td class="right">15:50-16:10</td><td class="left">Mahendra Naik</td><td class="left"><a href="#sec2.13">Large amounts of data downloading and processing in python with facebook data as reference</a></td></tr>
<tr><td class="right">16:10-16:20</td><td class="left">Sachin Shinde</td><td class="left"><a href="#sec2.22">Reverse Engineering and python</a></td></tr>
<tr><td class="right">16:20-17:00</td><td class="left"></td><td class="left"><b>Lightning Talks</b></td></tr>
</tbody>
</table>
<br/><br/>

<h2> Coverage</h2>
<h3 id="sec2.2">Ankur Gupta : Multiprocessing module and Gearman</h3>
<h4>Abstract</h4>
<p class="abstract">Large Data Sets and Multi-Core computers are becoming a common place in today's world. 
Code that utilizes all cores at disposal is prerequisite to process large data sets. 
Scaling over multiple machines/cluster allows for horizontal scaling. 
Drawing on experience of working with a Team at HP that created an near real time 
early warning software named OSSA. OSSA processed over 40TB+ compressed data at HP using 32 cores spread over 
a cluster of machine. Multiprocessing and Gearman ( a distributed job queue with Python bindings ) allows 
any simple python script to go distributed with minimal refactoring.</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.3">William Natharaj P.S: Automated Measurement of Magnetic properties of Ferro-Magnetic materials using Python</h3>
<h4>Abstract</h4>
<p>Hysterisis is basically a phenomenon where the behaviour of a system depends on the way the system moves.  
On increasing the magnetizing field H applied to a magnetic material ,  
the corresponding induction B traces a different path when it increases from that when the field  
decreases tracing a loop. It is often referred to as the  B-H loop.</p> 
<p>A ferromagnetic  specimen is placed co-axially in an applied magnetic field. 
The specimen gets magnetised and  the magnetisation undergoes a variation due to the varying field . 
This variation is picked up by a pickup coil which is placed co-axially with the specimen.  
The dB/dt signal thus pickedup  is propotional to dB/dt, which on integration gives the desired  B. 
The H field is sampled as proportional  to the energyzing current.</p>
<p>Data  acquisition of  H and dB/dt  is done using a microcontroller 
based Data acquisition system which is implimented in Python. 
The signal is acquired alternately choosing the H and the dB/dt. 
The acquired data is nose reduced by averaging over various cycles. 
The processed signal dB/dt  is integrated numerically making sure that 
the constant of integration chosen makes B swing equally on both sides of the H axis .  
The electronic circuitry used introduces an extra phase shift. 
This is nulled by running the experiment in air  where B-H curve is only a straight line. 
The retentivity, coercivity and the susceptibility of the specimen are calculated as the modulus 
of the  X and the modulus of the  Y intercepts . 
The result for steel agrees with reported values. 
This method also gives a way of calculating the hysterysis loss in the sample percycle.  
</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.6">Bala Subrahmanyam Varanasi : Sentiment Analysis</h3>
<h4>Abstract</h4>
<p>This talk will start with a quick overview of my topic - Sentiment analysis, its 
Applications, Opportunities and various Challenges involved in Sentiment Mining. 
Later, we present our machine learning experiments conducted using Natural Language Tool Kit 
(NLTK) with regard to sentiment analysis for the language "Telugu", where this work is less implemented.</p> 
<p>We have developed a Sentiment analyzer for Telugu Language.  
For that we developed movie review corpus from a popular website telugu.oneindia.com as our 
data set which is classified according to subjectivity/objectivity and negative/positive attitude.  
We used different approaches in extracting text features such as bag-of-words model, 
using large movie reviews corpus, restricting to adjectives and adverbs, 
handling negations and bounding word frequencies by a threshold. 
We conclude our study with explanation of observed trends in accuracy rates and providing directions for future work.</p>
<h4>Slides</h4>
<p>To be uploaded</p>
<h3 id="sec2.7">Vishal Kanaujia : Exploiting the power of multicore for scientific computing in Python</h3>
<h4>Abstract</h4>
<p>Multicore systems offer abundant potential for parallel computing, 
and Python developers are flocking to tap this power. 
Python is gaining popularity in high performance computing with rich set of libraries and frameworks.</p>
<p>Typically, scientific applications viz. modeling weather patterns, 
seismographic data, astronomical analysis etc, deal with huge data-set. 
Processing of this raw data for further analysis is a highly CPU-intensive task. 
Hence it is critical that design and development of these applications should 
look towards utilizing multiple CPU cores in an efficient manner for high performance.</p>

<p>This talk discusses different methods to achieve parallelism in 
Python applications and analyze these methods for effectiveness and suitability.</p> 

<h4>Agenda</h4>
<ul>
	<li>Problem context: Big data problem</li>
	<li>Designing Python programs for multicores</li>
	<li>Achieving parallelism
		<ul>
			<li>Multithreading and the infamous GIL</li>
			<li>Exploring multiprocessing</li>
			<li>Jython concurrency</li>
		</ul>
	</li>
</ul>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.8">Jayneil Dalal : Building Embedded Systems for Image Processing using Python</h3>
<h4>Abstract</h4>
<p>I plan to teach everyone how to import the very popular and powerful 
OpenCV library to Python and use it for image processing. 
I will also cover the installation of the same as it is a very 
cumbersome and a bit difficult task. Then we will do basic image processing programs . 
Then I will teach how to interact with an embedded system(Arduino) using Pyserial 
module and carry out different actions(Turn on LED etc.) 
So finally we will develop a full fledged embedded system. 
For e.g.: We will do image processing to detect a certain object in a given 
image and based on the output of that, the embedded system will do a certain task. 
If in a given image using facial recognition, a face is detected then an LED will be turned ON! All using python.
</p>
<h4>Slides</h4>
<p>To be uploaded</p>


<h3 id="sec2.9">Kunal Puri : Smoothed Particle Hydrodynamics with Python</h3>
<h4>Abstract</h4>
<p>We present PySPH as a framework for smoothed particle hydrodynamics simulations in Python. 
PySPH can be used for a wide class of problems including fluid dynamics, solid mechanics and 
compressible gas dynamics. We demonstrate how to run simulations and view the results with PySPH from the end-user's perspective.
</p> 

<p>Note: This is intended to be a magazine-style article as the PySPH architecture is discussed elsewhere.</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.10">Nivedita Datta : Encryptedly yours : Python & Cryptography</h3>
<h4>Abstract</h4>
<p>In today's world, the hard truth about protecting electronic messages and 
transactions is that no matter how advanced the technology being used, 
there is no guarantee of absolute security. As quickly as researchers develop 
ever-more-rigorous methods for keeping private information private, 
others figure out how to skirt those safeguards. That's particularly worrisome as our 
society becomes more and more dependent on e-commerce. Scientists say that even measures 
now considered virtually 'unbreakable' might someday be broken, by either mathematicians or 
computers that develop new algorithms to crack the protective code.
</p>

<h4>Agenda</h4>
<ul>
	<li>What is cryptography</li>
	<li>Why cryptography</li>
	<li>Basic terminologies</li>
	<li>
		Classification of cryptographic algorithms
		<ul>
			<li>Stream cipher and block ciphers</li>
			<li>Public key and private key algorithms</li>
		</ul>
	</li>
	<li>Introduction to hashing</li>
	<li>Introduction to pycrypto module</li>
	<li>pycrypto installation steps</li>
	<li>Code for few cryptographic and hashing algorithms</li>
</ul>

<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.13">Mahendra Naik : Large amounts of data downloading and processing in python with facebook data as reference</h3>
<p>Python is an easy to learn language which helps for rapid development of applications. 
The only visbile hindrance to python is the speed of processing ,primarily because it is a scripting language. 
Scientific computing involves processing large amounts of data in a very short period of time. 
This paper talks about an efficient algorithm to process massive(GB's) textual data in time interval of less than a second. 
There will not be any changes to core python. 
The existing python libraries will be used to process this data. 
The main aspect of the project is that we will not be dealing with the old data stored in the filesystem . 
We will be downloading data from the internet and the processing will happen in real-time. 
So, an effective caching , if any used should be implemented. 
A database like MYSQL will be used to store the data.</p> 
<p>Pythreads will be used for parallel downloading and processing of data. 
So a constant stream of huge data will be downloaded and later processed for the required data. 
This algorithm can find use in scientific applications where a large data needs to processes in real-time. 
And this will be achieved without making any changes to core python. 
The data we will be processing on would be retrieved from facebook. 
Facebook was choosen because of its massive userbase and the massive data stored for almost every user. 
Another reason for choosing facebook was the availability of api's to access data. 
Facebook exposes its data to developers through facebook platform. 
We will be using facebook's graph api to download data from facebook. 
Graph api stores each and every element from facebook as an id. 
The data from all the id's from 1 to a very huge number (eg:10 billion) 
will be extracted from facebook and will be processed to retrieve the required data. 
The main intention of the project is to implement an algorithm to process massive amounts of data in real time using python . 
As explained above we will take facebook as the reference data.</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.14">Hrishikesh Deshpande : Higher Order Statistics in Python</h3>
<h4>Abstract</h4>
<p>In many signal and image processing applications, correlation and power spectrum have been used as primary tools; the information contained in the power spectrum is provided by auto-correlation and is sufficient for complete statistical descriptions of Gaussian signals of known means. However, there exist some practical situations where one needs to look beyond auto-correlation operation to extract information pertaining to deviation from Gaussianity and the presence of phase relations. Higher Order Statistics (HOS) are the extensions of second order measures to higher orders and have proven to be useful in problems where non-gaussianity, non-minimal phase or non-linearity has some role to play. In recent years, the field of HOS has continued its expansion, and applications have been found in fields as diverse as economics, speech, medical, seismic data processing, plasma physics and optics. In this paper, we present a module named PyHOS, which provides elementary higher order statistics functions in Python and further discuss an application of HOS for biomedical signals. This module makes use of SciPy, Numpy and Matplotlib libraries in Python. To evaluate the module, we experimented with several complex signals and compared the results with equivalent procedures in MATLAB. The results showed that PyHOS is excellent module to analyze or study signals using their higher order statistics features.</p>
<h4>Slides</h4>
<p>To be uploaded</p>


<h3 id="sec2.18">Jaidev Deshpande : A Python Toolbox for the Hilbert-Huang Transform</h3>
<h4>Abstract</h4>
<p>This paper introduces the PyHHT project. The aim of the project is to develop a Python toolbox for the Hilbert-Huang Transform (HHT) for nonlinear and nonstationary data analysis. The HHT is an algorithmic tool particularly useful for the time-frequency analysis of nonlinear and nonstationary data. It uses an iterative algorithm called Empirical Mode Decomposition (EMD) to break a signal down into so-called Intrinsic Mode Functions (IMFs). These IMFs are characterized by being piecewise narrowband and amplitude/frequency modulated, thus making them suitable for Hilbert spectral analysis.</p>

<p>HHT is primarily an algorithmic tool and is relatively simple to implement. Therefore, even a crude implementation of the HHT is quite powerful for a given class of signals. Thus, one of the motivations for building a toolbox is to sustain the power of HHT across a variety of applications. This can be achieved by bringing together different heuristics associated with HHT on one programming platform (since HHT is largely algorithmic, there are a great many heuristics). It is thus the purpose of the toolbox to provide those implementations of the HHT that are popular in the literature. Along with making the application of HHT more dexterous and flexible, the toolbox will also be a good research tool as it provides a platform for comparison of different HHT implementations. It also supports comparison with conventional data analysis tools like Fourier and Wavelets.</p>

<p>Most of the existing implementations of the HHT have functions that are drawn from different numerical computing packages, and hence are generalized, not optimized particularly for HHT. PyHHT includes functions that are optimized specifically for analysis with HHT. They are designed to operate at the least possible computational complexity, thus greatly increasing the performance of the analysis. The paper includes examples of such components of EMD which have been optimized to operate at the least possible expense – in comparison with conventional implementations. This optimization can be done in a number of ways. One example of optimizing conventional algorithms for PyHHT discussed in the paper is that of cubic spline interpolation. It is a major bottleneck in the EMD method (needs to be performed twice over the entire range of the signal in a single iteration). Most implementations for cubic splines involve the use of Gaussian elimination, whereas for PyHHT the much simpler tridiagonal system of equations will suffice. Furthermore, it can be improved using many different methods like using NumPy vectorization, the weave and blitz functions in SciPy, or by using the Python-C/C++ API. Thus, the portability of Python comes in handy when optimizing the algorithm on so many different levels. The paper also discusses the possibility of further improving such functions that are the biggest bottlenecks in the EMD algorithm.</p>

<p>Other heuristics of the HHT include imposing different stopping conditions for the iterative EMD process. Once the IMFs of the original signal are obtained, their time-frequency-energy distributions can be obtained. PyHHT uses Matplotlib to visualize the distributions. The IMFs can further be used in computer vision and machine learning applications. PyHHT uses a number of statistical and information theoretic screening tools to detect the useful IMFs from among the decomposed data.</p>

<p>Finally we perform HHT on a few test signals and compare it with the corresponding Fourier and Wavelet analyses. We comment on the advantages and limitations of the HHT method and discuss future improvements in the PyHHT project.</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.19">Chetan Giridhar : Diving in to Byte-code optimization in Python</h3>
<h4>Abstract</h4>
<p>The rapid development cycle and performance makes Python as a preferred choice for HPC applications. Python is an interpreted language , running on Python Virtual Machine. Python VM then translates and executes byte-code on native platform. A Python application follows classical phases of compilation and byte-code generation is very similar to intermediate code. The byte-codes are platform neutral and enables Python applications with the power of portability. Performance of a Python application could factored on:
<ul>
	<li>Quality of generated byte-code</li> 
	<li>Efficiency of Python VM</li>
</ul>
</p>
<p>This talk discusses the internals of Python byte code, generation and potential optimization to improve run time performance of applications.</p>

<h4>Agenda</h4>
<ul>Python Virtual Machine: internals
<li>Reverse engineering: Python byte code ("pyc" files)
    <ul><li>Exploring Python dis-assembler for pyc</li></ul></li>
<li>Optimizing python byte code for time-efficiency
   <ul><li>Peephole optimization</li>
   <li>Tweaking the Python VM</li></ul></li>
<li>Does PyPy helps?</li>
</ul>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.21">Kunal puri : GPU Accelerated Computational Fluid Dynamics with Python</h3>
<h4>Abstract</h4>
<p>Computational fluid dynamics (CFD) is a field dominated by code that
is written in either Fortran or C/C++. An example is the well known
open source CFD tool, OpenFOAM, that adopts C++ as the language of
implementation.\newline A language like Python would be the ideal
choice but for the performance penalty incurred. Indeed, equivalent
Python code is at least an order of magnitude slower than C/C++ or
Fortran.</p>

<p>A common approach is to combine the best of both worlds wherein the
computationally expensive routines that form a small core is written
in a high performance language and the rest of the software framework
is built around this core using Python. We adopt such a model to
develop a code for the incompressible Navier Stokes equations using
OpenCL as the underlying language and target graphics processing units
(GPUs) as the execution device.
</p>
<p>
The data-parallel nature of most CFD algorithms renders them ideal for
execution on the highly parallel GPU architectures, which are designed
to run tens of thousands of light-weight threads simultaneously. The
result is that well designed GPU code can outperform it's CPU
counterpart by an order of magnitude in terms of speed.
</p>

<p>
We use the Python binding for OpenCL, PyOpenCL to run the code on the
GPU. The result is an almost pure Python CFD code that is faster than
it's CPU counterpart and is relatively easy to extend to more
complicated problems.  We consider only two dimensional domains with
structured Cartesian meshes for simplicity. We focus on GPU specific
optimizations of the code like memory coalescing, cache utilization
and memory transfer bandwidth which are essential for good
performance. Our target platform is a system with four Tesla c2050
Nvidia GPUs, each having 3 Gigabytes of global memory.\newline The
code is validated against solutions from an equivalent CPU version and
we present results for the transient incompressible flow past an
impulsively started cylinder.
</p>

<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.22">Sachin Shinde : Reverse Engineering and python</h3>
<h4>Abstract</h4>
<p>The paper is about how we can use python for writing tools for reverse engineering and assembly code analysis it will talk about basic and modules those are available for doing reverse engineering. </p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.23">Gael Varoquaux(Affiliation: INRIA Parietal, Neurospin, Saclay, France): Machine learning as a tool for Neuroscience</h3>
<h4>Abstract</h4>
<p>For now two decades, functional brain imaging has provided a tool for
building models of cognitive processes. However, these models are
ultimately introduced without a formal data analysis step. Indeed,
cognition arise from the interplay of many elementary functions. There
are an exponential amount of competing possible models, that cannot be
discriminated with a finite amount of data. This data analysis problem is
common in many experimental science settings, although seldom diagnosed.
In statistics, it is known as the <b>curse of dimensionality</b>, and can be
tackled efficiently with machine learning tools.</p>
<p>
For these reasons, imaging neuroscience has recently seen a
multiplication of complex data analysis methods. Yet, machine learning is
a rapidly-evolving research field, often leading to impenetrable
publication and challenging algorithms, of which neuroscience data
analysts only scratch the surface. 
</p>
<p>
I will present our efforts to foster a general-purpose machine-learning
Python module, <b>scikit-learn</b>, for scientific data analysis. As it aims
to bridge the gap between machine-learning researchers and end-users, the
package is focused on ease of use and high-quality documentation while
maintaining state-of-the-art performance. It is enjoying a growing
success in research laboratories, but also in communities with strong
industrial links such as web-analytics or natural language processing. 
</p>
<p>
We combine this module with high-end interactive
visualization using <b>Mayavi</b> and neuroimaging-specific tools in <b>nipy</b> to
apply state of the art machine learning techniques to neuroscience:
learning from the data new models of brain activity, focused on
predictive or descriptive power. These models can be used to perform
"brain reading": predicting behavior our thoughts from brain images. This
is a well-posed <b>supervised learning</b> problem. In <b>unsupervised</b>
settings, that is in the absence of behavioral observations, we focus on
learning probabilistic models of the signal. For instance, interaction
graphs between brain regions at rest reveal structures well-known to be
recruited in tasks. 
</p>
<p>
Optimal use of the data available from a brain imaging session raises
computational challenges that are well-known in large data analytics. The
<b>scipy</b> stack, including <b>Cython</b> and <b>scikit-learn</b>, used with care, can
provide a high-performance environment, matching dedicated solutions. I
will highlight how the <b>scikit-learn</b> performs efficient data analysis in
Python. 
</p>
<p>
The challenges discussed here go beyond neuroscience. Imaging
neuroscience is a test bed for advanced data analysis in science, as it
faces the challenge of integrating new data without relying on
well-established fundamental laws. However, with the data available in
experimental sciences growing rapidly, high-dimensional statistical
inference and data processing are becoming key in many other fields.
Python is set to provide a thriving ecosystem for these tasks, as it
unites scientific communities and web-based industries.
</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.24">IITB Students : Project Presentation</h3>
<h4>Abstract</h4>
<p>
The following 2 projects(part of the <a href="http://fossee.in/sdes">SDES</a> course) which obtained the highest marks;  
would be presented by respective project members.
</p>
<li>Digital Logic circuit simulator</li>
<li>Analysis and modelling of cellular systems</li>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.25">Dr Ole Nielsen : 7 Steps to Python Software That Works</h3>
<h4>Abstract</h4>
<p>
I will give an overview of Python projects I have been leading over
the past decade in academia, science agencies and government. These
include large scale datamining, parallel computing, hydrodynamic
modelling of tsunami impact and analysis of impact from natural
disasters. All projects are based on Python (and numpy). The purpose
of this talk is to summarise the practices I have come to see as
essential to produce software that works robustly and sensibly
is user and developer friendly, i.e. can be used and developed by a
diverse and changing team eventually takes on a life of its own 
without input from the core development team.
</p>
<p>
Much of this will be known to many of you, but having worked in this
field for some time now and seen much software it is my view that
there is still a lot of Python code that could really shine if
testing, source control, style guides, exception handling etc were
observed more generally. To keep it real, I'll show real examples where appropriate.
</p>
<h4>Slides</h4>
<p>To be uploaded</p>


<h3 id="sec2.26">Mateusz Paprocki : Understanding importance of automated software testing</h3>
<h4>Abstract</h4>
<p>
Development of scientific programs isn't much different than development of computer programs of any other kind. One of the key characteristic of computer programs is correctness. No matter whether we create programs for our own purpose or for other parties, we do not want to spent hours or days waiting for results of computations that will be flawed from the very beginning. As long as programs consist of few lines of code, we may be able to verify correctness of all cases in those programs manually after every change or even try to prove their correctness. However, real life programs consist of thousands, hundred thousands or even millions of lines of code, and even more states. In such a setup we need tools and methods that would allow to automate the process of software testing.
</p>
<p>
Python, a programming language with a weak dynamic type system, makes the use of automated software testing even more important because in this case test suites and the testing framework of choice have to accommodate for the weaknesses of the language. Also, agile software development techniques may intrinsically require automated testing as their core component to guarantee effectiveness of those methods.
</p>
<p>
In this talk I will show how to do automated testing of programs written in Python. Test automation tools will be described and common issues and pitfalls outlined. I will also discuss the notion of code coverage with tests and testing via examples (doctests).
</p>
<h4>Slides</h4>
<p>To be uploaded</p>

<h3 id="sec2.27">Emmanuelle Gouillart (joint laboratory CNRS/Saint-Gobain UMR 125,
39 quai Lucien Lefranc 93303 Aubervilliers, France): 3-D image processing and visualization with the scientific-Python stack</h3>
<h4>Abstract</h4>
<p>

Synchrotron X-ray tomography images the inner 3-D micro-structure of
objects. Recent progress bringing acquisition rates down to a few seconds
have opened the door to in-situ monitoring of material transformations
during, e.g., mechanical or heat treatments. However, this powerful
imaging technique presents many challenges, such as the huge size of
typical datasets, or the poor signal over noise ratio. In this talk, we
will present how the standard modules of the scientific Python stack,
combined with a few additional developments, are used to process and
visualize such 3-D tomography images for research purposes. The data
presented in this talk consist of 3-D images of window-glass raw
materials, that react together at high temperature to form liquids, and
images of glasses undergoing phase separation.3
</p>
<p>

Using the Traits module, it was possible to write at minimal cost a
custom graphical application with an embedded Mayavi scene to perform
"4-D visualization", that is, to display cuts through a 3-D volume that
can be updated with the next or previous image of the dataset. Easy
interaction with the data (placing markers) could also be added at
minimal cost. Efficient state-of-the-art algorithms for denoising images
and segmenting (extracting) objects were implemented using scipy, and
PyAMG for multigrid resolution of linear systems.
</p>
<p>

Finally, we will show how this work led us "naturally" to take part in
development efforts of open-source Scientific-python packages. Improving
the documentation of scipy.ndimage on the documentation wiki was a first
easy contribution. Then, one segmentation algorithm as well as one
denoising algorithm were contributed to the scikits-image package. We
will finish the talk by a brief overview of scikits-image and its
development process.
</p>
<p>

<h4>Slides</h4>
<p>To be uploaded</p>


{% endblock content %}

